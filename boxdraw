#!/usr/bin/env bash

set -euo pipefail

function boxdraw() {

	# if no stdin was provided, print help text:
	if [[ -t 0 ]]; then
		cat <<-EOF

		Usage:

		  boxdraw <<-EOF    # PRESS ENTER
		  > +-+             # PASTE INPUT
		  > +-+
		  > EOF             # ENTER "EOF"
		  ┌─┐               # PRESS ENTER
		  └─┘

		  OR

		  boxdraw < inputfile.txt

		Options:

		  boxdraw 8 < inputfile.txt         # Draw with margin of 8 lines/spaces
		  boxdraw 0 bold < inputfile.txt    # Draw with bold "box-drawing" characters
		  boxdraw 2 double < inputfile.txt  # Draw with double-line "box-drawing" characters AND margin

		More information:

		  https://github.com/evnp/boxdraw
		  https://en.wikipedia.org/wiki/Box-drawing_character

		EOF
		exit 1
	fi

	# first arg : margin (integer, optional) - define space around drawing
	local margin="${1:-0}"
	local marginchars=""
	local marginidx
	if (( margin > 0 )); then
		for (( marginidx=0 ; marginidx < margin ; marginidx++ )); do
			echo             # print top margin
			marginchars+=" " # calc string to be used for left margin
		done
	fi

	# second arg : style (integer or string enum [ light bold double ], optional)
	# 0 / light  - use thin-lined box-drawing characters
	# 1 / bold   - use thick-lined box-drawing characters
	# 2 / double - use double-lined box-drawing characters
	local style="${2:-0}"
	if [[ "${style}" == 'light' ]]; then
		style=0
	elif [[ "${style}" == 'bold' ]]; then
		style=1
	elif [[ "${style}" == 'double' ]]; then
		style=2
	elif [[ "${style}" =~ ^[012]$ ]]; then
		style=0
	fi

	# box-drawing character sets, indexed by cardinal directions:
	local nesw="┼╋╬"
	local nes_="├┣╠"
	local ne_w="┴┻╩"
	local ne__="└┗╚"
	local n_sw="┤┫╣"
	local n_s_="│┃║"
	local n__w="┘┛╝"
	local n___="╵╹║"
	local _esw="┬┳╦"
	local _es_="┌┏╔"
	local _e_w="─━═"
	local _e__="╶╺═"
	local __sw="┐┓╗"
	local __s_="╷╻║"
	local ___w="╴╸═"
	local ____="···"

	# other box-drawing charset management vars:
	local boxchar boxcharset boxcharsetidx boxcharsetvarname
	local boxcharsets=(
		"${nesw}"
		"${nes_}"
		"${ne_w}"
		"${ne__}"
		"${n_sw}"
		"${n_s_}"
		"${n__w}"
		"${n___}"
		"${_esw}"
		"${_es_}"
		"${_e_w}"
		"${_e__}"
		"${__sw}"
		"${__s_}"
		"${___w}"
		"${____}"
	)

	# line vars : current line, prev line, next line, output line:
	local curr prev next dest

	# char vars : char index ; idx plus 1 ; idx minus 1 ; current char
	local charidx charip1 charim1 curchar

	# cardinal directions : north, south, east, west
	local n e s w

	# start loop (bash has no do-while):
	curr=1

	while [[ -n "${next:-}" || -n "${curr:-}" ]]; do
		[[ "${curr}" != 1 ]] && prev="${curr:-}"
		curr="${next:-}"

		IFS= read -r next || true  # don't exit once we read empty line

		if [[ -n "${curr}" ]]; then
			dest=""
			for (( charidx=0 ; charidx < "${#curr}" ; charidx++ )); do
				charim1=$(( charidx - 1 ))
				charip1=$(( charidx + 1 ))
				curchar="${curr:${charidx}:1}"

				if [[ -n "$( charoneof "${curchar}" '|' + - │ ─ )" ]]; then
					n=_ ; [[ -n "${prev}" && -n "$( charoneof "${prev:${charidx}:1}" '|' +   │   ┼ ┤ ├   ┬ )" ]] && n=n
					e=_ ; [[ -n "${curr}" && -n "$( charoneof "${curr:${charip1}:1}"     + -   ─ ┼ ┤   ┴ ┬ )" ]] && e=e
					s=_ ; [[ -n "${next}" && -n "$( charoneof "${next:${charidx}:1}" '|' +   │   ┼ ┤ ├ ┴   )" ]] && s=s
					w=_ ; [[ -n "${curr}" && -n "$( charoneof "${curr:${charim1}:1}"     + -   ─ ┼   ├ ┴ ┬ )" ]] && w=w
					(( charim1 < 0 )) && w=_ # don't allow negative indexing on curr line
					boxcharsetvarname="${n}${e}${s}${w}"
					boxcharset="${!boxcharsetvarname}"
					boxchar="${boxcharset:${style}:1}"
				else
					boxchar="${curchar}"
					for (( boxcharsetidx=0 ; boxcharsetidx < ${#boxcharsets[@]} ; boxcharsetidx++ )); do
						boxcharset="${boxcharsets[${boxcharsetidx}]}"
						if [[ "${boxchar}" == "${boxcharset:0:1}" ]]; then
							boxchar="${boxcharset:${style}:1}"
							break
						fi
					done
				fi
				dest+="${boxchar}"
			done
			echo "${marginchars}${dest}"
		else
			echo
		fi
	done

	if (( margin > 0 )); then
		# print bottom margin:
		for (( marginidx=0 ; marginidx < margin ; marginidx++ )); do echo; done
	fi
}

# if first arg exactly equals one of the other args, print 1
# else print nothing
# ex. if [[ -n charoneof "${var}" + - * / ]]; then echo "${var} is an operator"; fi
function charoneof() {
	local char="$1"
	shift
	local oneof=( "$@" )
	local i

	for (( i=0 ; i < "${#oneof[@]}" ; i++ )); do
		if [[ "${char}" == "${oneof[${i}]}" ]]; then
			echo 1
			break
		fi
	done

	return 0
}

boxdraw "$@"
